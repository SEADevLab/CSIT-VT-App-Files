const { default: mongoose } = require("mongoose");
const MalwareFile = require("../models/malwarefileModel");
const formidable = require("formidable");
const extract = require("extract-zip");
const crypto = require("crypto");
const fs = require("fs");
const path = require("path");
const { db } = require("../models/malwarefileModel");
const fsExtra = require("fs-extra");
const { flattenDir } = require("./flattendir");

const uploadDir = path.join(__dirname, "../uploads/zip_files");
const extractDir = path.join(__dirname, "../uploads/extracted_files");
const flattenedDir = path.join(__dirname, "../uploads/flattened_dir_files");

if (!fs.existsSync(path.join(__dirname, "../uploads"))) {
  fs.mkdirSync(path.join(__dirname, "../uploads"));
}

if (!fs.existsSync(uploadDir)) {
  fs.mkdirSync(uploadDir);
}
if (!fs.existsSync(extractDir)) {
  fs.mkdirSync(extractDir);
}
if (!fs.existsSync(flattenedDir)) {
  fs.mkdirSync(flattenedDir);
}
function round(num) {
  var m = Number((Math.abs(num) * 100).toPrecision(15));
  return (Math.round(m) / 100) * Math.sign(num);
}

// get all malware files
const getAllMalwareFiles = async (req, res) => {
  const malwarefiles = await MalwareFile.find({}).sort({ createdAt: -1 });
  res.status(200).json(malwarefiles);
};

// get a single malware file
const getMalwareFile = async (req, res) => {
  const { id } = req.params;

  if (!mongoose.Types.ObjectId.isValid(id)) {
    return res.status(404).json({ error: "No such file" });
  }

  const malwarefile = await MalwareFile.findById(id);

  if (!malwarefile) {
    return res.status(404).json({ error: "No such file" });
  }
  res.status(200).json(malwarefile);
};

// get malware files based on hash
const hashSearchMalwareFile = async (req, res) => {
  const hashtype = req.params.hashtype;
  const hash = req.params.hash;
  console.log(hashtype, hash);
  const malwarefiles = await MalwareFile.find({ [`hashes.${hashtype}`]: hash });

  if (malwarefiles.length === 0) {
    return res.status(404).json({ error: "No such file" });
  }
  res.status(200).json(malwarefiles);
};

// submit a new malware file
const submitMalwareFile = async (req, res) => {
  const { filename, description, user, hashes } = req.body;
  try {
    const malwarefile = await MalwareFile.create({
      filename,
      description,
      user,
      hashes,
    });
    res.status(200).json(malwarefile);
  } catch (error) {
    res.status(404).json({ error: error.message });
  }
};

const uploadMalwareFile = async (req, res) => {
  try {
    if (!req.files) {
      res.status(400).json({ error: "No file uploaded" });
    } else {
      //Use the name of the input field (i.e. "avatar") to retrieve the uploaded file
      const uploadedFile = req.files.uploadedFile;
      console.log(uploadedFile);

      //Use the mv() method to place the file in upload directory (i.e. "uploads")
      // uploadedFile.mv("./uploads/" + uploadedFile.name);

      hashalgos = ["md5", "sha1", "sha256"];
      hashesobj = {};

      hashalgos.forEach((hashalgo) => {
        const hashSum = crypto.createHash(hashalgo);
        hashSum.update(uploadedFile.data);

        const hex = hashSum.digest("hex");
        Object.assign(hashesobj, { [`${hashalgo}`]: hex });
      });

      const checkDuplicateFile = await MalwareFile.findOne({
        filename: uploadedFile.name,
        hashes: hashesobj,
      });

      if (checkDuplicateFile) {
        return res
          .status(200)
          .json({ mssg: "File already exists and will not be uploaded" });
      }

      const malwarefileDetails = req.body;
      Object.assign(malwarefileDetails, {
        filename: uploadedFile.name,
        hashes: hashesobj,
        filesize: round(uploadedFile.size / 1000000) + "MB",
      });
      console.log(malwarefileDetails);

      try {
        const malwarefile = await MalwareFile.create(malwarefileDetails);
        res.status(200).json(malwarefile);
      } catch (error) {
        res.status(404).json({ error: error.message });
      }
    }
  } catch (err) {
    res.status(500).send(err);
  }
};

const uploadMalwareZipFile = async (req, res) => {
  const form = formidable({
    maxFileSize: 100 * 1024 * 1024,
    keepExtensions: true,
    multiples: true,
    uploadDir: uploadDir,
  });

  extractedZipFiles = [];
  var formfiles = await new Promise((resolve, reject) => {
    form.parse(req, (err, fields, files) => {
      try {
        if (err) {
          reject(err);
          return res.status(500).json({ error: error.message });
        }

        if (Object.keys(files).length === 0) {
          return res.status(400).json({ message: "no files uploaded" });
        }
        const filesInfo = Object.keys(files).map((key) => {
          const file = files[key];
          const filePath = file.filepath;
          const fileExt = path.extname(file.originalFilename);
          const fileName = path.basename(file.originalFilename, fileExt);

          return { filePath, fileExt, fileName };
        });

        // Check whether uploaded files are zip files
        const validFiles = filesInfo.every(({ fileExt }) => fileExt === ".zip");

        if (!validFiles) {
          return res.status(400).json({ message: "unsupported file type" });
        }

        filesInfo.forEach(({ filePath, fileName }) => {
          // create directory with timestamp to prevent overwrite same directory names
          const destDir = `${path.join(
            extractDir,
            fileName
          )}_${new Date().getTime()}`;

          // pass deleteSource = true if source file not needed after extraction
          const dbUpload = [];
          const extractZip = async (file, destination) => {
            await extract(file, { dir: destination });

            flattenDir(destination, flattenedDir);

            filenames = fs.readdirSync(flattenedDir);

            filenames.forEach((filename) => {
              const fileData = fs.readFileSync(flattenedDir + "//" + filename);

              hashalgos = ["md5", "sha1", "sha256"];
              hashesobj = [];
              hashalgos.forEach((hashalgo) => {
                const hashSum = crypto.createHash(hashalgo);
                hashSum.update(fileData);

                const hex = hashSum.digest("hex");
                Object.assign(hashesobj, { [`${hashalgo}`]: hex });
              });
              const malwarefileDetails = {};
              Object.assign(malwarefileDetails, {
                filename: filename,
                description: fields.description,
                user: fields.user,
                hashes: {
                  md5: hashesobj.md5,
                  sha1: hashesobj.sha1,
                  sha256: hashesobj.sha256,
                },
              });
              dbUpload.push(malwarefileDetails);
            });
          };
          extractZip(filePath, destDir).then(() => {
            extractedZipFiles.push(dbUpload);
            resolve(dbUpload);
          });
        });
      } catch (err) {}
    });
  });
  fsExtra.emptyDirSync(uploadDir);
  fsExtra.emptyDirSync(extractDir);
  fsExtra.emptyDirSync(flattenedDir);

  const originalLength = formfiles.length;
  await new Promise((resolve) => {
    let count = 0;
    formfiles.forEach(async (formfile) => {
      try {
        const checkDuplicateFile = await MalwareFile.findOne({
          filename: formfile.filename,
          hashes: formfile.hashes,
        });
        if (checkDuplicateFile) {
          formfiles = formfiles.filter((item) => item !== formfile);
        }
      } catch (e) {
        console.log(e);
      } finally {
        count++;
        if (count === originalLength) {
          resolve();
        }
      }
    });
  });

  if (formfiles.length > 0) {
    if (formfiles.length != originalLength) {
      try {
        const malwarefiles = await MalwareFile.insertMany(formfiles);
        res
          .status(200)
          .json({ message: "Some files were duplicates", malwarefiles });
      } catch (error) {
        res.status(404).json({ error: error.message });
      }
    } else {
      try {
        const malwarefiles = await MalwareFile.insertMany(formfiles);
        res.status(200).json(malwarefiles);
      } catch (error) {
        res.status(404).json({ error: error.message });
      }
    }
  } else {
    res
      .status(400)
      .json({ message: "No files uploaded, All files were duplicates" });
  }
};

module.exports = {
  getAllMalwareFiles,
  getMalwareFile,
  submitMalwareFile,
  hashSearchMalwareFile,
  uploadMalwareFile,
  uploadMalwareZipFile,
};

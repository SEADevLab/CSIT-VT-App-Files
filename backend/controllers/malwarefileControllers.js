const { default: mongoose } = require("mongoose");
const MalwareFile = require("../models/malwarefileModel");
const formidable = require("formidable");
const extract = require("extract-zip");
const crypto = require("crypto");
const fs = require("fs");
const path = require("path");
const { db } = require("../models/malwarefileModel");
const fsExtra = require("fs-extra");
const { flattenDir } = require("./flattendir");

const uploadDir = path.join(__dirname, "../uploads/zip_files");
const extractDir = path.join(__dirname, "../uploads/extracted_files");
const flattenedDir = path.join(__dirname, "../uploads/flattened_dir_files");

if (!fs.existsSync(path.join(__dirname, "../uploads"))) {
  fs.mkdirSync(path.join(__dirname, "../uploads"));
}

if (!fs.existsSync(uploadDir)) {
  fs.mkdirSync(uploadDir);
}
if (!fs.existsSync(extractDir)) {
  fs.mkdirSync(extractDir);
}
if (!fs.existsSync(flattenedDir)) {
  fs.mkdirSync(flattenedDir);
}
function round(num) {
  var m = Number((Math.abs(num) * 100).toPrecision(15));
  return (Math.round(m) / 100) * Math.sign(num);
}

// get all malware files
const getAllMalwareFiles = async (req, res) => {
  const malwarefiles = await MalwareFile.find({}).sort({ createdAt: -1 });
  res.status(200).json(malwarefiles);
};

// get a single malware file
const getMalwareFile = async (req, res) => {
  const { id } = req.params;

  if (!mongoose.Types.ObjectId.isValid(id)) {
    return res.status(404).json({ error: "No such file" });
  }

  const malwarefile = await MalwareFile.findById(id);

  if (!malwarefile) {
    return res.status(404).json({ error: "No such file" });
  }
  res.status(200).json(malwarefile);
};

// get malware files based on hash
const hashSearchMalwareFile = async (req, res) => {
  const hashtype = req.params.hashtype;
  const hash = req.params.hash;
  console.log(hashtype, hash);
  const malwarefiles = await MalwareFile.find({ [`hashes.${hashtype}`]: hash });

  if (malwarefiles.length === 0) {
    return res.status(404).json({ error: "No such file" });
  }
  res.status(200).json(malwarefiles);
};

// submit a new malware file
const submitMalwareFile = async (req, res) => {
  const { filename, description, user, hashes } = req.body;
  try {
    const malwarefile = await MalwareFile.create({
      filename,
      description,
      user,
      hashes,
    });
    res.status(200).json(malwarefile);
  } catch (error) {
    res.status(404).json({ error: error.message });
  }
};

const uploadMalwareFile = async (req, res) => {
  try {
    if (!req.files) {
      res.status(400).json({ error: "No file uploaded" });
    } else {
      const uploadedFile = req.files.uploadedFile;
      console.log(uploadedFile);

      hashalgos = ["md5", "sha1", "sha256"];
      hashesobj = {};

      hashalgos.forEach((hashalgo) => {
        const hashSum = crypto.createHash(hashalgo);
        hashSum.update(uploadedFile.data);

        const hex = hashSum.digest("hex");
        Object.assign(hashesobj, { [`${hashalgo}`]: hex });
      });

      const checkDuplicateFile = await MalwareFile.findOne({
        filename: uploadedFile.name,
        hashes: hashesobj,
      });

      if (checkDuplicateFile) {
        return res
          .status(200)
          .json({ mssg: "File already exists and will not be uploaded" });
      }

      const malwarefileDetails = req.body;
      Object.assign(malwarefileDetails, {
        filename: uploadedFile.name,
        hashes: hashesobj,
        filesize: round(uploadedFile.size / 1000000) + "MB",
      });
      console.log(malwarefileDetails);

      try {
        const malwarefile = await MalwareFile.create(malwarefileDetails);
        res.status(200).json(malwarefile);
      } catch (error) {
        res.status(404).json({ error: error.message });
      }
    }
  } catch (err) {
    res.status(500).send(err);
  }
};

const uploadMalwareZipFile = async (req, res) => {
  try {
    // form options
    const form = formidable({
      maxFileSize: 100 * 1024 * 1024, // 100MB file size limit
      keepExtensions: true,
      multiples: true, // allow multiple files to be uploaded
      uploadDir: uploadDir,
    });

    var formfiles = await new Promise((resolve, reject) => {
      form.parse(req, (err, fields, files) => {
        try {
          if (err) {
            reject(err);
            return res.status(500).json({ error: error.message });
          }

          if (Object.keys(files).length === 0) {
            return res.status(400).json({ message: "no files uploaded" });
          }
          const filesInfo = Object.keys(files).map((key) => {
            const file = files[key];
            const filePath = file.filepath;
            const fileExt = path.extname(file.originalFilename);
            const fileName = path.basename(file.originalFilename, fileExt);

            return { filePath, fileExt, fileName };
          });

          // Check whether uploaded files are zip files
          const validFiles = filesInfo.every(
            ({ fileExt }) => fileExt === ".zip"
          );

          if (!validFiles) {
            return res.status(400).json({ message: "unsupported file type" });
          }

          filesInfo.forEach(({ filePath, fileName }) => {
            // create directory with timestamp to prevent overwrite same directory names
            const destDir = `${path.join(
              extractDir,
              fileName
            )}_${new Date().getTime()}`;

            const dbUpload = [];
            const extractZip = async (file, destination, fields) => {
              await extract(file, { dir: destination });

              // Flatten extracted file directory -> move files into flattened_dir_files folder
              flattenDir(destination, flattenedDir);

              // Iterate through each file in flattened_dir_files folder
              filenames = fs.readdirSync(flattenedDir);
              filenames.forEach((filename) => {
                // Read file contents
                const fileData = fs.readFileSync(
                  flattenedDir + "//" + filename
                );

                // Obtain hash of file
                const hashesobj = (() => {
                  const hashalgos = ["md5", "sha1", "sha256"];
                  let hashStore = [];
                  hashalgos.forEach((hashalgo) => {
                    const hashSum = crypto.createHash(hashalgo);
                    hashSum.update(fileData);

                    const hex = hashSum.digest("hex");
                    Object.assign(hashStore, { [`${hashalgo}`]: hex });
                  });
                  return hashStore;
                })();

                // Create object containing the details of the file
                const malwarefileDetails = (() => {
                  const malwarefileDetails = {};
                  try {
                    Object.assign(malwarefileDetails, {
                      filename: filename,
                      description: fields.description,
                      user: fields.user,
                      hashes: {
                        md5: hashesobj.md5,
                        sha1: hashesobj.sha1,
                        sha256: hashesobj.sha256,
                      },
                    });
                  } catch (err) {}
                  return malwarefileDetails;
                })();
                dbUpload.push(malwarefileDetails);
              });
            };
            extractZip(filePath, destDir, fields).then(() => {
              if (dbUpload.length > 0) {
                resolve(dbUpload);
              } else {
                reject();
              }
            });
          });
        } catch (err) {}
      });
    });
    // Clear directories used to temporarily store files
    const deleteFiles = (uploadDir, extractDir, flattenedDir) => {
      fsExtra.emptyDirSync(uploadDir);
      fsExtra.emptyDirSync(extractDir);
      fsExtra.emptyDirSync(flattenedDir);
    };
    deleteFiles(uploadDir, extractDir, flattenedDir);

    const originalLength = formfiles.length;
    const duplicateFiles = [];

    // Check for duplicates between uploaded files and DB
    await new Promise((resolve) => {
      let count = 0;
      formfiles.forEach(async (formfile) => {
        try {
          const checkDuplicateFile = await MalwareFile.find({
            filename: formfile.filename,
            hashes: formfile.hashes,
          });
          if (checkDuplicateFile.length > 0) {
            duplicateFiles.push(formfile);
          }
        } catch (e) {
          console.log(e);
        } finally {
          count++;
          if (count === originalLength) {
            resolve();
          }
        }
      });
    });

    formfiles = formfiles.filter((item) => !duplicateFiles.includes(item));

    console.log("upload", formfiles);
    console.log("duplicates", duplicateFiles);
    // Upload files to DB
    if (formfiles.length > 0) {
      if (formfiles.length != originalLength) {
        try {
          const malwarefiles = await MalwareFile.insertMany(formfiles);
          res.status(200).json({
            message: "Some files were duplicates",
            malwarefiles,
            duplicateFiles,
          });
        } catch (error) {
          res.status(404).json({ error: error.message });
        }
      } else {
        try {
          const malwarefiles = await MalwareFile.insertMany(formfiles);
          res.status(200).json({ message: "All files uploaded", malwarefiles });
        } catch (error) {
          res.status(404).json({ error: error.message });
        }
      }
    } else {
      const malwarefiles = [];
      res.status(200).json({
        message: "No files uploaded, All files were duplicates",
        duplicateFiles,
      });
    }
  } catch (error) {
    res.status(404).json({ error: "yes" });
  }
};

const uploadZipFile = async (req, res) => {
  try {
    // form options
    const form = formidable({
      maxFileSize: 100 * 1024 * 1024, // 100MB file size limit
      keepExtensions: true,
      multiples: true, // allow multiple files to be uploaded
      uploadDir: uploadDir,
    });

    var formfiles = await new Promise((resolve, reject) => {
      form.parse(req, (err, fields, files) => {
        try {
          if (err) {
            reject(err);
            return res.status(500).json({ error: error.message });
          }

          if (Object.keys(files).length === 0) {
            return res.status(400).json({ message: "no files uploaded" });
          }
          const filesInfo = Object.keys(files).map((key) => {
            const file = files[key];
            const filePath = file.filepath;
            const fileExt = path.extname(file.originalFilename);
            const fileName = path.basename(file.originalFilename, fileExt);

            return { filePath, fileExt, fileName };
          });

          // Check whether uploaded files are zip files
          const validFiles = filesInfo.every(
            ({ fileExt }) => fileExt === ".zip"
          );

          if (!validFiles) {
            return res.status(400).json({ message: "unsupported file type" });
          }

          filesInfo.forEach(({ filePath, fileName }) => {
            // create directory with timestamp to prevent overwrite same directory names
            const destDir = `${path.join(
              extractDir,
              fileName
            )}_${new Date().getTime()}`;

            const dbUpload = [];
            const extractZip = async (file, destination, fields) => {
              await extract(file, { dir: destination });

              // Flatten extracted file directory -> move files into flattened_dir_files folder
              flattenDir(destination, flattenedDir);

              // Iterate through each file in flattened_dir_files folder
              filenames = fs.readdirSync(flattenedDir);
              filenames.forEach((filename) => {
                // Read file contents
                const fileData = fs.readFileSync(
                  flattenedDir + "//" + filename
                );

                // Obtain hash of file
                const hashesobj = (() => {
                  const hashalgos = ["md5", "sha1", "sha256"];
                  let hashStore = [];
                  hashalgos.forEach((hashalgo) => {
                    const hashSum = crypto.createHash(hashalgo);
                    hashSum.update(fileData);

                    const hex = hashSum.digest("hex");
                    Object.assign(hashStore, { [`${hashalgo}`]: hex });
                  });
                  return hashStore;
                })();

                // Create object containing the details of the file
                const malwarefileDetails = (() => {
                  const malwarefileDetails = {};
                  try {
                    Object.assign(malwarefileDetails, {
                      filename: filename,
                      description: fields.description,
                      user: fields.user,
                      hashes: {
                        md5: hashesobj.md5,
                        sha1: hashesobj.sha1,
                        sha256: hashesobj.sha256,
                      },
                    });
                  } catch (err) {}
                  return malwarefileDetails;
                })();
                dbUpload.push(malwarefileDetails);
              });
            };
            extractZip(filePath, destDir, fields).then(() => {
              if (dbUpload.length > 0) {
                resolve(dbUpload);
              } else {
                reject();
              }
            });
          });
        } catch (err) {}
      });
    });
    // Clear directories used to temporarily store files
    const deleteFiles = (uploadDir, extractDir, flattenedDir) => {
      fsExtra.emptyDirSync(uploadDir);
      fsExtra.emptyDirSync(extractDir);
      fsExtra.emptyDirSync(flattenedDir);
    };
    deleteFiles(uploadDir, extractDir, flattenedDir);

    const originalLength = formfiles.length;
    const duplicateFiles = [];

    // Check for duplicates between uploaded files and DB
    await new Promise((resolve) => {
      let count = 0;
      formfiles.forEach(async (formfile) => {
        try {
          const checkDuplicateFile = await MalwareFile.find({
            filename: formfile.filename,
            hashes: formfile.hashes,
          });
          if (checkDuplicateFile.length > 0) {
            duplicateFiles.push(formfile);
          }
        } catch (e) {
          console.log(e);
        } finally {
          count++;
          if (count === originalLength) {
            resolve();
          }
        }
      });
    });

    formfiles = formfiles.filter((item) => !duplicateFiles.includes(item));
    const malwarefiles = formfiles;
    res.status(200).json({
      malwarefiles,
      duplicateFiles,
    });
  } catch (err) {}
};

const submitMalwareFiles = async (req, res) => {
  uploadFiles = req.body;

  const originalLength = uploadFiles.length;
  const duplicateFiles = [];

  await new Promise((resolve) => {
    let count = 0;
    uploadFiles.forEach(async (formfile) => {
      try {
        const checkDuplicateFile = await MalwareFile.find({
          filename: formfile.filename,
          hashes: formfile.hashes,
        });
        if (checkDuplicateFile.length > 0) {
          duplicateFiles.push(formfile);
        }
      } catch (e) {
        console.log(e);
      } finally {
        count++;
        if (count === originalLength) {
          resolve();
        }
      }
    });
  });

  if (duplicateFiles.length === 0) {
    if (uploadFiles.length > 0) {
      try {
        const malwarefiles = await MalwareFile.insertMany(uploadFiles);
        res.status(200).json({
          malwarefiles,
        });
      } catch (error) {
        res.status(404).json({ error: error.message });
      }
    } else {
      res.status(200).json({ message: "No Files to upload" });
    }
  }else{
    res.status(200).json({ message: "Duplicate Files Detected. Please Submit Form Again" });
  }
};
module.exports = {
  getAllMalwareFiles,
  getMalwareFile,
  submitMalwareFile,
  hashSearchMalwareFile,
  uploadMalwareFile,
  uploadMalwareZipFile,
  uploadZipFile,
  submitMalwareFiles,
};
